mjolnir es un sistema distribuído.
Consiste de un proceso maestro(PM/Pm), que es el que guarda el estado real
del sistema, y canales de comunicación con los procesos satélite(Pn), que
guardan estimaciones del estado real del sistema. Cada Pn se subdivide en 
tres hilos: hilo del Diagrama, hilo de la GUI, hilo de Redes.
Las relaciones de estos tres hilos son complejas, y siguen un patrón que tengo
aún por esclarecer y formalizar:
Comparten acceso a variables comunes a nivel Pn, y cada uno posee acceso a 
variables locales a su propio dominio. Qué quiere decir esto? Que tenemos una
jerarquía "de localidad":

P1D P1R P1G  P2D P2R P2G  P2D P2R P2G  ...

  `  '  ´      `  '  ´      `  '  ´
     P1           P2          P3    ...
      
        `         '        ´
                  PM

La principal forma (pero no la única) mediante la cual PM altera su propio
estado es a través de los Pn, sin embargo, ningún Pn conoce el estado real del
sistema en su totalidad.
Las operaciones que Pn efectúa sobre PM, definámoslas como transacciones, pueden
arrojar excepciones, pues dos Pn pueden estar accediendo al mismo recurso al
mismo tiempo. En esencia es como un problema de multithreading, pero cada "hilo"
es un integrante del sistema, lo cual dificulta enormemente la atomicidad de las
operaciones. Me gustaría investigar si existe algún concepto similar a un
"mutex de red". Las implicaciones de latencia son obvias, pero haría falta
evidencia empírica para asegurar que sobre una red local son o no perjudiciales.
Al parecer el concepto de mutex de red no es alg nuevo y existe en bases de datos 
y sistemas distribuidos de manera común.
El escenario del error sería el siguiente:
1. Represento el estado de un objeto (al mismo tiempo éste es modificado por otro Pn)
2. Lo modifico (para entonces Pm ya fue notificado del cambio por el otro Pn y notifica
   a todos los Pn (incluido yo mismo) de este cambio.
3. Aviso a Pn de mi propio cambio (para entonces yo ya tengo en mi pila de mensajes
   que localmente debo modificar esa variable)
4. Pn avisa a todos de ese cambio y sobreescribe el recurso modificado.

Es un caso claro del típico ejemplo RRWW, donde la primera escritura es sobreescrita
por la segunda.
No podemos lockear la lectura, pues sería extremadamente ineficiente (imagina cuántas
lecturas hacemos todo el tiempo). Lo que sí podemos es hacer escrituras que fallen.
El truco está en determinar las condiciones bajo las cuales debemos determinar que
una escritura fallará.
Esto lo debe determinar PM (Si pudiera hacerse en Pn sería genial pues distribuyes el peso
de la computación). Si pudiera "desglosar" el tipo de transacciones realizables.

---------------------------------------------------------------------------------


Estoy reflexionando sobre lo asequible de la tarea de construir este sistema. Realmente
me hace falta conseguir más colaboradores, el espacio para cometer errores de diseño es
muy amplio, y no me considero un experto en muchos de los temas relevantes para hacerlo.
Existen demasiadas ideas, demasiadas posibilidades. El lenguaje permite construcciones
muy complejas. smart_ptrs, vector, map, tuple, iostreams, etc.
Necesito encontrar una manera para capacitar a la gente a que pueda ayudarme a desarrollar.

---------------------------------------------------------------------------------

Tomando como referencia el curso de presupuesto, necesitas un plan de desarrollo de SW.
No puedes seguir desarrollando de una manera campechana feature tras feature. Debes
establecer metas concretas.
S Específico
M Medible
A Asequible
R Relevante
T Timely

"Fallar en planear es planear fallar"

----------------------------------------------------------------------------------

Para desencadenar eventos en la GUI diseñé un sistema de std::queue<int(*)()>
Es un buffer FIFO de apuntadores a funciones. Cuando algún otro hilo desea que alguna
ventana de la GUI emerja, le pasa a este buffer (a través de una función que usa un mutex)
el apuntador a la función que quiera sea llamada (por el hilo de la GUI). De esta manera,
la pertenencia de los recursos reservados por esta función es de la GUI, y no del hilo que
la desencadenó. Esto evita que la interfaz sea irresponsiva si cerramos el hilo que
desencadenó este evento (por ejemplo el diagrama).

